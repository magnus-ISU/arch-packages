#!/usr/bin/env bash
version=7.1.0
bash_version=${BASH_VERSINFO[0]:-5}
shopt -s eval_unsafe_arith &>/dev/null
sys_locale=${LANG:-C}
PATH=$PATH:/usr/xpg4/bin:/usr/sbin:/sbin:/usr/etc:/usr/libexec
reset='\e[0m'
shopt -s nocasematch
LC_ALL=C
LANG=C
export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/
read -rd '' config <<'EOF'
EOF
get_os() {
	os=Linux
}
get_distro() {
	[[ $distro ]] && return
	if [[ -f /etc/os-release || \
			-f /usr/lib/os-release || \
			-f /etc/openwrt_release || \
			-f /etc/lsb-release ]]; then
		for file in /etc/lsb-release /usr/lib/os-release \
					/etc/os-release  /etc/openwrt_release; do
			source "$file" && break
		done
		case $distro_shorthand in
			on)   distro="${NAME:-${DISTRIB_ID}} ${VERSION_ID:-${DISTRIB_RELEASE}}" ;;
			tiny) distro="${NAME:-${DISTRIB_ID:-${TAILS_PRODUCT_NAME}}}" ;;
			off)  distro="${PRETTY_NAME:-${DISTRIB_DESCRIPTION}} ${UBUNTU_CODENAME}" ;;
		esac
	fi
	distro=$(trim_quotes "$distro")
	distro=${distro/NAME=}
	[[ $distro ]] || distro="$os (Unknown)"
	case $os in
		Solaris|AIX|Haiku|IRIX|FreeMiNT)
			machine_arch=$(uname -p)
		;;
		*)  machine_arch=$kernel_machine ;;
	esac
	[[ $os_arch == on ]] && \
		distro+=" $machine_arch"
	[[ ${ascii_distro:-auto} == auto ]] && \
		ascii_distro=$(trim "$distro")
}
get_model() {
	if [[ -d /system/app/ && -d /system/priv-app ]]; then
		model="$(getprop ro.product.brand) $(getprop ro.product.model)"
	elif [[ -f /sys/devices/virtual/dmi/id/product_name ||
			-f /sys/devices/virtual/dmi/id/product_version ]]; then
		model=$(< /sys/devices/virtual/dmi/id/product_name)
		model+=" $(< /sys/devices/virtual/dmi/id/product_version)"
	elif [[ -f /sys/firmware/devicetree/base/model ]]; then
		model=$(< /sys/firmware/devicetree/base/model)
	elif [[ -f /tmp/sysinfo/model ]]; then
		model=$(< /tmp/sysinfo/model)
	fi
	model=${model//To be filled by O.E.M.}
	model=${model//To Be Filled*}
	model=${model//OEM*}
	model=${model//Not Applicable}
	model=${model//System Product Name}
	model=${model//System Version}
	model=${model//Undefined}
	model=${model//Default string}
	model=${model//Not Specified}
	model=${model//Type1ProductConfigId}
	model=${model//INVALID}
	model=${model//All Series}
	model=${model//ï¿½}
	case $model in
		"Standard PC"*) model="KVM/QEMU (${model})" ;;
		OpenBSD*)	   model="vmm ($model)" ;;
	esac
}
get_title() {
	user=${USER:-$(id -un || printf %s "${HOME/*\/}")}
	case $title_fqdn in
		on) hostname=$(hostname -f) ;;
		*)  hostname=${HOSTNAME:-$(hostname)} ;;
	esac
	title=${title_color}${bold}${user}${at_color}@${title_color}${bold}${hostname}
	length=$((${#user} + ${#hostname} + 1))
}
get_kernel() {
	case $kernel_shorthand in
		on)  kernel=$kernel_version ;;
		off) kernel="$kernel_name $kernel_version" ;;
	esac
}
get_uptime() {
	uptime=$(uptime -p | cut -b 4-)
	uptime=${uptime/minutes/mins}
	case $uptime_shorthand in
		on) ;;
		tiny)
			uptime=${uptime/ days/d}
			uptime=${uptime/ day/d}
			uptime=${uptime/ hours/h}
			uptime=${uptime/ hour/h}
			uptime=${uptime/ mins/m}
			uptime=${uptime/ min/m}
			uptime=${uptime/ secs/s}
			uptime=${uptime//,}
		;;
	esac
}
get_packages() {
	has() { type -p "$1" >/dev/null && manager=$1; }
	dir() { ((packages+=$#)); pac "$#"; }
	pac() { (($1 > 0)) && { managers+=("$1 (${manager})"); manager_string+="${manager}, "; }; }
	tot() { IFS=$'\n' read -d "" -ra pkgs <<< "$("$@")";((packages+=${#pkgs[@]}));pac "${#pkgs[@]}";}
	case $os in
		Linux|BSD|"iPhone OS"|Solaris)
			has kiss	   && tot kiss l
			has pacman-key && tot pacman -Qq --color never
			has dpkg	   && tot dpkg-query -f '.\n' -W
			has rpm		&& tot rpm -qa
			has xbps-query && tot xbps-query -l
			has apk		&& tot apk info
			has opkg	   && tot opkg list-installed
			has pacman-g2  && tot pacman-g2 -Q
			has lvu		&& tot lvu installed
			has tce-status && tot tce-status -i
			has pkg_info   && tot pkg_info
			has tazpkg	 && tot tazpkg list && ((packages-=6))
			has sorcery	&& tot gaze installed
			has alps	   && tot alps showinstalled
			has butch	  && tot butch list
			has mine	   && tot mine -q
			{
			shopt -s nullglob
			has brew	&& dir "$(brew --cellar)"/*
			has emerge  && dir ${br_prefix}/var/db/pkg/*/*/
			has Compile && dir ${br_prefix}/Programs/*/
			has eopkg   && dir ${br_prefix}/var/lib/eopkg/package/*
			has crew	&& dir ${br_prefix}/usr/local/etc/crew/meta/*.filelist
			has pkgtool && dir ${br_prefix}/var/log/packages/*
			has scratch && dir ${br_prefix}/var/lib/scratchpkg/index/*/.pkginfo
			has kagami  && dir ${br_prefix}/var/lib/kagami/pkgs/*
			has cave	&& dir ${br_prefix}/var/db/paludis/repositories/cross-installed/*/data/*/ \
							   ${br_prefix}/var/db/paludis/repositories/installed/data/*/
			shopt -u nullglob
			}
			has kpm-pkg && ((packages+=$(kpm  --get-selections | grep -cv deinstall$)))
			has guix && {
				manager=guix-system && tot guix package -p "/run/current-system/profile" -I
				manager=guix-user   && tot guix package -I
			}
			has nix-store && {
				manager=nix-system  && tot nix-store -q --requisites /run/current-system/sw
				manager=nix-user	&& tot nix-store -q --requisites ~/.nix-profile
				manager=nix-default && tot nix-store -q --requisites /nix/var/nix/profiles/default
			}
			has pkginfo && tot pkginfo -i
			case $kernel_name in
				FreeBSD|DragonFly) has pkg && tot pkg info ;;
				*)
					has pkg && dir /var/db/pkg/*
					((packages == 0)) && \
						has pkg && tot pkg list
				;;
			esac
			has flatpak && tot flatpak list
			has spm	 && tot spm list -i
			has puyo	&& dir ~/.puyo/installed
			has snap && ps -e | grep -qFm 1 snapd >/dev/null && tot snap list && ((packages-=1))
			manager=appimage && has appimaged && dir ~/.local/bin/*.appimage
		;;
	esac
	if ((packages == 0)); then
		unset packages
	elif [[ $package_managers == on ]]; then
		printf -v packages '%s, ' "${managers[@]}"
		packages=${packages%,*}
	elif [[ $package_managers == tiny ]]; then
		packages+=" (${manager_string%,*})"
	fi
	packages=${packages/pacman-key/pacman}
}
get_shell() {
	case $shell_path in
		on)  shell="$SHELL " ;;
		off) shell="${SHELL##*/} " ;;
	esac
	[[ $shell_version != on ]] && return
	case ${shell_name:=${SHELL##*/}} in
		bash)
			[[ $BASH_VERSION ]] ||
				BASH_VERSION=$("$SHELL" -c "printf %s \"\$BASH_VERSION\"")
			shell+=${BASH_VERSION/-*}
		;;
		sh|ash|dash|es) ;;
		*ksh)
			shell+=$("$SHELL" -c "printf %s \"\$KSH_VERSION\"")
			shell=${shell/ * KSH}
			shell=${shell/version}
		;;
		osh)
			if [[ $OIL_VERSION ]]; then
				shell+=$OIL_VERSION
			else
				shell+=$("$SHELL" -c "printf %s \"\$OIL_VERSION\"")
			fi
		;;
		tcsh)
			shell+=$("$SHELL" -c "printf %s \$tcsh")
		;;
		yash)
			shell+=$("$SHELL" --version 2>&1)
			shell=${shell/ $shell_name}
			shell=${shell/ Yet another shell}
			shell=${shell/Copyright*}
		;;
		*)
			shell+=$("$SHELL" --version 2>&1)
			shell=${shell/ $shell_name}
		;;
	esac
	shell=${shell/, version}
	shell=${shell/xonsh\//xonsh }
	shell=${shell/options*}
	shell=${shell/\(*\)}
}
get_de() {
	((de_run == 1)) && return
	((wm_run != 1)) && get_wm
	if [[ $DESKTOP_SESSION == regolith ]]; then
		de=Regolith
	elif [[ $XDG_CURRENT_DESKTOP ]]; then
		de=${XDG_CURRENT_DESKTOP/X\-}
		de=${de/Budgie:GNOME/Budgie}
		de=${de/:Unity7:ubuntu}
	elif [[ $DESKTOP_SESSION ]]; then
		de=${DESKTOP_SESSION##*/}
	elif [[ $GNOME_DESKTOP_SESSION_ID ]]; then
		de=GNOME
	elif [[ $MATE_DESKTOP_SESSION_ID ]]; then
		de=MATE
	elif [[ $TDE_FULL_SESSION ]]; then
		de=Trinity
	fi
	[[ $de == "$wm" ]] && { unset -v de; return; }
	[[ $DISPLAY && -z $de ]] && type -p xprop &>/dev/null && \
		de=$(xprop -root | awk '/KDE_SESSION_VERSION|^_MUFFIN|xfce4|xfce5/')
	case $de in
		KDE_SESSION_VERSION*) de=KDE${de/* = } ;;
		*xfce4*)  de=Xfce4 ;;
		*xfce5*)  de=Xfce5 ;;
		*xfce*)   de=Xfce ;;
		*mate*)   de=MATE ;;
		*GNOME*)  de=GNOME ;;
		*MUFFIN*) de=Cinnamon ;;
	esac
	((${KDE_SESSION_VERSION:-0} >= 4)) && de=${de/KDE/Plasma}
	if [[ $de_version == on && $de ]]; then
		case $de in
			Plasma*)   de_ver=$(plasmashell --version) ;;
			MATE*)	 de_ver=$(mate-session --version) ;;
			Xfce*)	 de_ver=$(xfce4-session --version) ;;
			GNOME*)	de_ver=$(gnome-shell --version) ;;
			Cinnamon*) de_ver=$(cinnamon --version) ;;
			Deepin*)   de_ver=$(awk -F'=' '/Version/ {print $2}' /etc/deepin-version) ;;
			Budgie*)   de_ver=$(budgie-desktop --version) ;;
			LXQt*)	 de_ver=$(lxqt-session --version) ;;
			Lumina*)   de_ver=$(lumina-desktop --version 2>&1) ;;
			Trinity*)  de_ver=$(tde-config --version) ;;
			Unity*)	de_ver=$(unity --version) ;;
		esac
		de_ver=${de_ver/*TDE:}
		de_ver=${de_ver/tde-config*}
		de_ver=${de_ver/liblxqt*}
		de_ver=${de_ver/Copyright*}
		de_ver=${de_ver/)*}
		de_ver=${de_ver/* }
		de_ver=${de_ver//\"}
		de="$de $de_ver"
	fi
	de_run=1
}
get_wm() {
	((wm_run == 1)) && return
	ps_flags=(-e)
	if [[ $WAYLAND_DISPLAY ]]; then
		wm=$(ps "${ps_flags[@]}" | grep -m 1 -o -F \
						   -e arcan \
						   -e asc \
						   -e clayland \
						   -e dwc \
						   -e fireplace \
						   -e gnome-shell \
						   -e greenfield \
						   -e grefsen \
						   -e kwin \
						   -e lipstick \
						   -e maynard \
						   -e mazecompositor \
						   -e motorcar \
						   -e orbital \
						   -e orbment \
						   -e perceptia \
						   -e rustland \
						   -e sway \
						   -e ulubis \
						   -e velox \
						   -e wavy \
						   -e way-cooler \
						   -e wayfire \
						   -e wayhouse \
						   -e westeros \
						   -e westford \
						   -e weston)
	elif [[ $DISPLAY && $os != "Mac OS X" && $os != "macOS" && $os != FreeMiNT ]]; then
		type -p xprop &>/dev/null && {
			id=$(xprop -root -notype _NET_SUPPORTING_WM_CHECK)
			id=${id##* }
			wm=$(xprop -id "$id" -notype -len 100 -f _NET_WM_NAME 8t)
			wm=${wm/*WM_NAME = }
			wm=${wm/\"}
			wm=${wm/\"*}
		}
		[[ $wm ]] ||
			wm=$(ps "${ps_flags[@]}" | grep -m 1 -o \
							   -e "[s]owm" \
							   -e "[c]atwm" \
							   -e "[f]vwm" \
							   -e "[d]wm" \
							   -e "[2]bwm" \
							   -e "[m]onsterwm" \
							   -e "[t]inywm" \
							   -e "[x]11fs" \
							   -e "[x]monad")
	fi
	[[ $wm == *WINDOWMAKER* ]] && wm=wmaker
	[[ $wm == *GNOME*Shell* ]] && wm=Mutter
	wm_run=1
}
get_wm_theme() {
	((wm_run != 1)) && get_wm
	((de_run != 1)) && get_de
	case $wm  in
		E16)
			wm_theme=$(awk -F "= " '/theme.name/ {print $2}' "${HOME}/.e16/e_config--0.0.cfg")
		;;
		Sawfish)
			wm_theme=$(awk -F '\\(quote|\\)' '/default-frame-style/ {print $(NF-4)}' \
					   "$HOME/.sawfish/custom")
		;;
		Cinnamon|Muffin|"Mutter (Muffin)")
			detheme=$(gsettings get org.cinnamon.theme name)
			wm_theme=$(gsettings get org.cinnamon.desktop.wm.preferences theme)
			wm_theme="$detheme ($wm_theme)"
		;;
		Compiz|Mutter|Gala)
			if type -p gsettings >/dev/null; then
				wm_theme=$(gsettings get org.gnome.shell.extensions.user-theme name)
				[[ ${wm_theme//\'} ]] || \
					wm_theme=$(gsettings get org.gnome.desktop.wm.preferences theme)
			elif type -p gconftool-2 >/dev/null; then
				wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
			fi
		;;
		Metacity*)
			if [[ $de == Deepin ]]; then
				wm_theme=$(gsettings get com.deepin.wrap.gnome.desktop.wm.preferences theme)
			elif [[ $de == MATE ]]; then
				wm_theme=$(gsettings get org.mate.Marco.general theme)
			else
				wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
			fi
		;;
		E17|Enlightenment)
			if type -p eet >/dev/null; then
				wm_theme=$(eet -d "$HOME/.e/e/config/standard/e.cfg" config |\
							awk '/value \"file\" string.*.edj/ {print $4}')
				wm_theme=${wm_theme##*/}
				wm_theme=${wm_theme%.*}
			fi
		;;
		Fluxbox)
			[[ -f $HOME/.fluxbox/init ]] &&
				wm_theme=$(awk -F "/" '/styleFile/ {print $NF}' "$HOME/.fluxbox/init")
		;;
		IceWM*)
			[[ -f $HOME/.icewm/theme ]] &&
				wm_theme=$(awk -F "[\",/]" '!/#/ {print $2}' "$HOME/.icewm/theme")
		;;
		Openbox)
			case $de in
				LXDE*) ob_file=lxde-rc ;;
				LXQt*) ob_file=lxqt-rc ;;
					*) ob_file=rc ;;
			esac
			ob_file=$XDG_CONFIG_HOME/openbox/$ob_file.xml
			[[ -f $ob_file ]] &&
				wm_theme=$(awk '/<theme>/ {while (getline n) {if (match(n, /<name>/))
							{l=n; exit}}} END {split(l, a, "[<>]"); print a[3]}' "$ob_file")
		;;
		PekWM)
			[[ -f $HOME/.pekwm/config ]] &&
				wm_theme=$(awk -F "/" '/Theme/{gsub(/\"/,""); print $NF}' "$HOME/.pekwm/config")
		;;
		Xfwm4)
			[[ -f $HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml ]] &&
				wm_theme=$(xfconf-query -c xfwm4 -p /general/theme)
		;;
		KWin*)
			kde_config_dir
			kwinrc=$kde_config_dir/kwinrc
			kdebugrc=$kde_config_dir/kdebugrc
			if [[ -f $kwinrc ]]; then
				wm_theme=$(awk '/theme=/ {
									gsub(/theme=.*qml_|theme=.*svg__/,"",$0);
									print $0;
									exit
								 }' "$kwinrc")
				[[ "$wm_theme" ]] ||
					wm_theme=$(awk '/library=org.kde/ {
										gsub(/library=org.kde./,"",$0);
										print $0;
										exit
									 }' "$kwinrc")
				[[ $wm_theme ]] ||
					wm_theme=$(awk '/PluginLib=kwin3_/ {
										gsub(/PluginLib=kwin3_/,"",$0);
										print $0;
										exit
									 }' "$kwinrc")
			elif [[ -f $kdebugrc ]]; then
				wm_theme=$(awk '/(decoration)/ {gsub(/\[/,"",$1); print $1; exit}' "$kdebugrc")
			fi
			wm_theme=${wm_theme/theme=}
		;;
		"Quartz Compositor")
			global_preferences=$HOME/Library/Preferences/.GlobalPreferences.plist
			wm_theme=$(PlistBuddy -c "Print AppleInterfaceStyle" "$global_preferences")
			wm_theme_color=$(PlistBuddy -c "Print AppleAccentColor" "$global_preferences")
			[[ "$wm_theme" ]] ||
				wm_theme=Light
			case $wm_theme_color in
				-1) wm_theme_color=Graphite ;;
				0)  wm_theme_color=Red ;;
				1)  wm_theme_color=Orange ;;
				2)  wm_theme_color=Yellow ;;
				3)  wm_theme_color=Green ;;
				5)  wm_theme_color=Purple ;;
				6)  wm_theme_color=Pink ;;
				*)  wm_theme_color=Blue ;;
			esac
			wm_theme="$wm_theme_color ($wm_theme)"
		;;
		*Explorer)
			path=/proc/registry/HKEY_CURRENT_USER/Software/Microsoft
			path+=/Windows/CurrentVersion/Themes/CurrentTheme
			wm_theme=$(head -n1 "$path")
			wm_theme=${wm_theme##*\\}
			wm_theme=${wm_theme%.*}
		;;
		Blackbox|bbLean*)
			path=$(wmic process get ExecutablePath | grep -F "blackbox")
			path=${path//\\/\/}
			wm_theme=$(grep '^session\.styleFile:' "${path/\.exe/.rc}")
			wm_theme=${wm_theme/session\.styleFile: }
			wm_theme=${wm_theme##*\\}
			wm_theme=${wm_theme%.*}
		;;
	esac
	wm_theme=$(trim_quotes "$wm_theme")
}
get_cpu() {
	cpu_file="/proc/cpuinfo"
	case $kernel_machine in
		"frv" | "hppa" | "m68k" | "openrisc" | "or"* | "powerpc" | "ppc"* | "sparc"*)
			cpu="$(awk -F':' '/^cpu\t|^CPU/ {printf $2; exit}' "$cpu_file")"
		;;
		"s390"*)
			cpu="$(awk -F'=' '/machine/ {print $4; exit}' "$cpu_file")"
		;;
		"ia64" | "m32r")
			cpu="$(awk -F':' '/model/ {print $2; exit}' "$cpu_file")"
			[[ -z "$cpu" ]] && cpu="$(awk -F':' '/family/ {printf $2; exit}' "$cpu_file")"
		;;
		*)
			cpu="$(awk -F '\\s*: | @' \
					'/model name|Hardware|Processor|^cpu model|chip type|^cpu type/ {
					cpu=$2; if ($1 == "Hardware") exit } END { print cpu }' "$cpu_file")"
		;;
	esac
	speed_dir="/sys/devices/system/cpu/cpu0/cpufreq"
	for temp_dir in /sys/class/hwmon/*; do
		[[ "$(< "${temp_dir}/name")" =~ (coretemp|fam15h_power|k10temp) ]] && {
			temp_dirs=("$temp_dir"/temp*_input)
			temp_dir=${temp_dirs[0]}
			break
		}
	done
	if [[ -d "$speed_dir" ]]; then
		speed="$(< "${speed_dir}/${speed_type}")" ||\
		speed="$(< "${speed_dir}/bios_limit")" ||\
		speed="$(< "${speed_dir}/scaling_max_freq")" ||\
		speed="$(< "${speed_dir}/cpuinfo_max_freq")"
		speed="$((speed / 1000))"
	else
		speed="$(awk -F ': |\\.' '/cpu MHz|^clock/ {printf $2; exit}' "$cpu_file")"
		speed="${speed/MHz}"
	fi
	[[ -f "$temp_dir" ]] && deg="$(($(< "$temp_dir") * 100 / 10000))"
	case $cpu_cores in
		"logical" | "on") cores="$(grep -c "^processor" "$cpu_file")" ;;
		"physical") cores="$(awk '/^core id/&&!a[$0]++{++i} END {print i}' "$cpu_file")" ;;
	esac
	cpu="${cpu//(TM)}"
	cpu="${cpu//(tm)}"
	cpu="${cpu//(R)}"
	cpu="${cpu//(r)}"
	cpu="${cpu//CPU}"
	cpu="${cpu//Processor}"
	cpu="${cpu//Dual-Core}"
	cpu="${cpu//Quad-Core}"
	cpu="${cpu//Six-Core}"
	cpu="${cpu//Eight-Core}"
	cpu="${cpu//[1-9][0-9]-Core}"
	cpu="${cpu//[0-9]-Core}"
	cpu="${cpu//, * Compute Cores}"
	cpu="${cpu//Core / }"
	cpu="${cpu//(\"AuthenticAMD\"*)}"
	cpu="${cpu//with Radeon * Graphics}"
	cpu="${cpu//, altivec supported}"
	cpu="${cpu//FPU*}"
	cpu="${cpu//Chip Revision*}"
	cpu="${cpu//Technologies, Inc}"
	cpu="${cpu//Core2/Core 2}"
	cores="${cores//[[:space:]]}"
	speed="${speed//[[:space:]]}"
	if [[ "$cpu_brand" == "off" ]]; then
		cpu="${cpu/AMD }"
		cpu="${cpu/Intel }"
		cpu="${cpu/Core? Duo }"
		cpu="${cpu/Qualcomm }"
	fi
	[[ "$cpu_cores" != "off" && "$cores" ]] && \
		case $os in
			"Mac OS X"|"macOS") cpu="${cpu/@/(${cores}) @}" ;;
			*)				  cpu="$cpu ($cores)" ;;
		esac
	if [[ "$cpu_speed" != "off" && "$speed" ]]; then
		if (( speed < 1000 )); then
			cpu="$cpu @ ${speed}MHz"
		else
			[[ "$speed_shorthand" == "on" ]] && speed="$((speed / 100))"
			speed="${speed:0:1}.${speed:1}"
			cpu="$cpu @ ${speed}GHz"
		fi
	fi
	if [[ "$cpu_temp" != "off" && "$deg" ]]; then
		deg="${deg//.}"
		[[ "$cpu_temp" == "F" ]] && deg="$((deg * 90 / 50 + 320))"
		deg="[${deg/${deg: -1}}.${deg: -1}Â°${cpu_temp:-C}]"
		cpu="$cpu $deg"
	fi
}
get_cpu_usage() {
	if [[ "$cpu_cores" != "logical" ]]; then
		case $os in
			"Linux" | "MINIX")  cores="$(grep -c "^processor" /proc/cpuinfo)" ;;
			"Mac OS X"|"macOS") cores="$(sysctl -n hw.logicalcpu_max)" ;;
			"BSD")			  cores="$(sysctl -n hw.ncpu)" ;;
			"Solaris")		  cores="$(kstat -m cpu_info | grep -c -F "chip_id")" ;;
			"Haiku")			cores="$(sysinfo -cpu | grep -c -F 'CPU #')" ;;
			"iPhone OS")		cores="${cpu/*\(}"; cores="${cores/\)*}" ;;
			"IRIX")			 cores="$(sysconf NPROC_ONLN)" ;;
			"FreeMiNT")		 cores="$(sysctl -n hw.ncpu)" ;;
			"AIX")
				cores="$(lparstat -i | awk -F':' '/Online Virtual CPUs/ {printf $2}')"
			;;
		esac
	fi
	cpu_usage="$(ps aux | awk 'BEGIN {sum=0} {sum+=$3}; END {print sum}')"
	cpu_usage="$((${cpu_usage/\.*} / ${cores:-1}))"
	case $cpu_display in
		"bar")	 cpu_usage="$(bar "$cpu_usage" 100)" ;;
		"infobar") cpu_usage="${cpu_usage}% $(bar "$cpu_usage" 100)" ;;
		"barinfo") cpu_usage="$(bar "$cpu_usage" 100)${info_color} ${cpu_usage}%" ;;
		*)		 cpu_usage="${cpu_usage}%" ;;
	esac
}
get_gpu() {
	gpu_cmd="$(lspci -mm | awk -F '\"|\" \"|\\(' \
								  '/"Display|"3D|"VGA/ {a[$0] = $1 " " $3 " " $4}
								   END {for(i in a) {if(!seen[a[i]]++) print a[i]}}')"
	IFS=$'\n' read -d "" -ra gpus <<< "$gpu_cmd"
	[[ "${gpus[0]}" == *Intel* && "${gpus[1]}" == *Intel* ]] && unset -v "gpus[0]"
	for gpu in "${gpus[@]}"; do
		[[ "$gpu_type" == "dedicated" && "$gpu" == *Intel* ]] || \
		[[ "$gpu_type" == "integrated" && ! "$gpu" == *Intel* ]] && \
			{ unset -v gpu; continue; }
		case $gpu in
			*"Advanced"*)
				brand="${gpu/*AMD*ATI*/AMD ATI}"
				brand="${brand:-${gpu/*AMD*/AMD}}"
				brand="${brand:-${gpu/*ATI*/ATi}}"
				gpu="${gpu/\[AMD\/ATI\] }"
				gpu="${gpu/\[AMD\] }"
				gpu="${gpu/OEM }"
				gpu="${gpu/Advanced Micro Devices, Inc.}"
				gpu="${gpu/*\[}"
				gpu="${gpu/\]*}"
				gpu="$brand $gpu"
			;;
			*"NVIDIA"*)
				gpu="${gpu/*\[}"
				gpu="${gpu/\]*}"
				gpu="NVIDIA $gpu"
			;;
			*"Intel"*)
				gpu="${gpu/*Intel/Intel}"
				gpu="${gpu/\(R\)}"
				gpu="${gpu/Corporation}"
				gpu="${gpu/ \(*}"
				gpu="${gpu/Integrated Graphics Controller}"
				gpu="${gpu/*Xeon*/Intel HD Graphics}"
				[[ -z "$(trim "$gpu")" ]] && gpu="Intel Integrated Graphics"
			;;
			*"MCST"*)
				gpu="${gpu/*MCST*MGA2*/MCST MGA2}"
			;;
			*"VirtualBox"*)
				gpu="VirtualBox Graphics Adapter"
			;;
			*) continue ;;
		esac
		if [[ "$gpu_brand" == "off" ]]; then
			gpu="${gpu/AMD }"
			gpu="${gpu/NVIDIA }"
			gpu="${gpu/Intel }"
		fi
		prin "${subtitle:+${subtitle}${gpu_name}}" "$gpu"
	done
	if [[ "$gpu_brand" == "off" ]]; then
		gpu="${gpu/AMD}"
		gpu="${gpu/NVIDIA}"
		gpu="${gpu/Intel}"
	fi
}
get_memory() {
	while IFS=":" read -r a b; do
		case $a in
			"MemTotal") ((mem_used+=${b/kB})); mem_total="${b/kB}" ;;
			"Shmem") ((mem_used+=${b/kB}))  ;;
			"MemFree" | "Buffers" | "Cached" | "SReclaimable")
				mem_used="$((mem_used-=${b/kB}))"
			;;
		esac
	done < /proc/meminfo
	mem_used="$((mem_used / 1024))"
	mem_total="$((mem_total / 1024))"
	[[ "$memory_percent" == "on" ]] && ((mem_perc=mem_used * 100 / mem_total))
	case $memory_unit in
		gib)
			mem_used=$(awk '{printf "%.2f", $1 / $2}' <<< "$mem_used 1024")
			mem_total=$(awk '{printf "%.2f", $1 / $2}' <<< "$mem_total 1024")
			mem_label=GiB
		;;
		kib)
			mem_used=$((mem_used * 1024))
			mem_total=$((mem_total * 1024))
			mem_label=KiB
		;;
	esac
	memory="${mem_used}${mem_label:-MiB} / ${mem_total}${mem_label:-MiB} ${mem_perc:+(${mem_perc}%)}"
	case $memory_display in
		"bar")	 memory="$(bar "${mem_used}" "${mem_total}")" ;;
		"infobar") memory="${memory} $(bar "${mem_used}" "${mem_total}")" ;;
		"barinfo") memory="$(bar "${mem_used}" "${mem_total}")${info_color} ${memory}" ;;
	esac
}
get_resolution() {
	if type -p xrandr >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
		case $refresh_rate in
			"on")
				resolution="$(xrandr --nograb --current |\
							  awk 'match($0,/[0-9]*\.[0-9]*\*/) {
								   printf $1 " @ " substr($0,RSTART,RLENGTH) "Hz, "}')"
			;;
			"off")
				resolution="$(xrandr --nograb --current |\
							  awk -F 'connected |\\+|\\(' \
									 '/ connected.*[0-9]+x[0-9]+\+/ && $2 {printf $2 ", "}')"
				resolution="${resolution/primary, }"
				resolution="${resolution/primary }"
			;;
		esac
		resolution="${resolution//\*}"
	elif type -p xwininfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
		read -r w h \
			<<< "$(xwininfo -root | awk -F':' '/Width|Height/ {printf $2}')"
		resolution="${w}x${h}"
	elif type -p xdpyinfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
		resolution="$(xdpyinfo | awk '/dimensions:/ {printf $2}')"
	elif [[ -d /sys/class/drm ]]; then
		for dev in /sys/class/drm/*/modes; do
			read -r resolution _ < "$dev"
			[[ $resolution ]] && break
		done
	fi
	resolution="${resolution%,*}"
	[[ -z "${resolution/x}" ]] && resolution=
}
get_style() {
	unset gtk2_theme gtk3_theme theme path
	if [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
		((de_run != 1)) && get_de
		[[ $de_version == on ]] && de=${de/ *}
		case $de in
			"KDE"* | "Plasma"*)
				kde_config_dir
				if [[ -f "${kde_config_dir}/kdeglobals" ]]; then
					kde_config_file="${kde_config_dir}/kdeglobals"
					kde_theme="$(grep "^${kde}" "$kde_config_file")"
					kde_theme="${kde_theme/*=}"
					if [[ "$kde" == "font" ]]; then
						kde_font_size="${kde_theme#*,}"
						kde_font_size="${kde_font_size/,*}"
						kde_theme="${kde_theme/,*} ${kde_theme/*,} ${kde_font_size}"
					fi
					kde_theme="$kde_theme [$de], "
				else
					err "Theme: KDE config files not found, skipping."
				fi
			;;
			*"Cinnamon"*)
				if type -p gsettings >/dev/null; then
					gtk3_theme="$(gsettings get org.cinnamon.desktop.interface "$gsettings")"
					gtk2_theme="$gtk3_theme"
				fi
			;;
			"Gnome"* | "Unity"* | "Budgie"*)
				if type -p gsettings >/dev/null; then
					gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"
					gtk2_theme="$gtk3_theme"
				elif type -p gconftool-2 >/dev/null; then
					gtk2_theme="$(gconftool-2 -g /desktop/gnome/interface/"$gconf")"
				fi
			;;
			"Mate"*)
				gtk3_theme="$(gsettings get org.mate.interface "$gsettings")"
				gtk2_theme="$gtk3_theme"
			;;
			"Xfce"*)
				type -p xfconf-query >/dev/null && \
					gtk2_theme="$(xfconf-query -c xsettings -p "$xfconf")"
			;;
		esac
		if [[ -z "$gtk2_theme" ]]; then
			if [[ -n "$GTK2_RC_FILES" ]]; then
				IFS=: read -ra rc_files <<< "$GTK2_RC_FILES"
				gtk2_theme="$(grep "^[^#]*${name}" "${rc_files[@]}")"
			elif [[ -f "${HOME}/.gtkrc-2.0"  ]]; then
				gtk2_theme="$(grep "^[^#]*${name}" "${HOME}/.gtkrc-2.0")"
			elif [[ -f "/etc/gtk-2.0/gtkrc" ]]; then
				gtk2_theme="$(grep "^[^#]*${name}" /etc/gtk-2.0/gtkrc)"
			elif [[ -f "/usr/share/gtk-2.0/gtkrc" ]]; then
				gtk2_theme="$(grep "^[^#]*${name}" /usr/share/gtk-2.0/gtkrc)"
			fi
			gtk2_theme="${gtk2_theme/*${name}*=}"
		fi
		if [[ -z "$gtk3_theme" ]]; then
			if [[ -f "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini" ]]; then
				gtk3_theme="$(grep "^[^#]*$name" "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini")"
			elif type -p gsettings >/dev/null; then
				gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"
			elif [[ -f "/etc/gtk-3.0/settings.ini" ]]; then
				gtk3_theme="$(grep "^[^#]*$name" /etc/gtk-3.0/settings.ini)"
			elif [[ -f "/usr/share/gtk-3.0/settings.ini" ]]; then
				gtk3_theme="$(grep "^[^#]*$name" /usr/share/gtk-3.0/settings.ini)"
			fi
			gtk3_theme="${gtk3_theme/${name}*=}"
		fi
		gtk2_theme="$(trim "$gtk2_theme")"
		gtk3_theme="$(trim "$gtk3_theme")"
		gtk2_theme="$(trim_quotes "$gtk2_theme")"
		gtk3_theme="$(trim_quotes "$gtk3_theme")"
		[[ "$gtk2" == "off" ]] && unset gtk2_theme
		[[ "$gtk3" == "off" ]] && unset gtk3_theme
		if [[ "$gtk2_theme" && "$gtk2_theme" == "$gtk3_theme" ]]; then
			gtk3_theme+=" [GTK2/3]"
			unset gtk2_theme
		elif [[ "$gtk2_theme" && "$gtk3_theme" ]]; then
			gtk2_theme+=" [GTK2], "
			gtk3_theme+=" [GTK3] "
		else
			[[ "$gtk2_theme" ]] && gtk2_theme+=" [GTK2] "
			[[ "$gtk3_theme" ]] && gtk3_theme+=" [GTK3] "
		fi
		theme="${kde_theme}${gtk2_theme}${gtk3_theme}"
		theme="${theme%, }"
		if [[ "$gtk_shorthand" == "on" ]]; then
			theme="${theme// '[GTK'[0-9]']'}"
			theme="${theme/ '[GTK2/3]'}"
			theme="${theme/ '[KDE]'}"
			theme="${theme/ '[Plasma]'}"
		fi
	fi
}
get_theme() {
	name="gtk-theme-name"
	gsettings="gtk-theme"
	gconf="gtk_theme"
	xfconf="/Net/ThemeName"
	kde="Name"
	get_style
}
get_icons() {
	name="gtk-icon-theme-name"
	gsettings="icon-theme"
	gconf="icon_theme"
	xfconf="/Net/IconThemeName"
	kde="Theme"
	get_style
	icons="$theme"
}
get_font() {
	name="gtk-font-name"
	gsettings="font-name"
	gconf="font_theme"
	xfconf="/Gtk/FontName"
	kde="font"
	get_style
	font="$theme"
}
get_term() {
	((term_run == 1)) && return
	case $TERM_PROGRAM in
		"iTerm.app")	term="iTerm2" ;;
		"Terminal.app") term="Apple Terminal" ;;
		"Hyper")		term="HyperTerm" ;;
		*)			  term="${TERM_PROGRAM/\.app}" ;;
	esac
	[[ "$TERM" == "tw52" || "$TERM" == "tw100" ]] && term="TosWin2"
	[[ "$SSH_CONNECTION" ]] && term="$SSH_TTY"
	[[ "$WT_SESSION" ]]	 && term="Windows Terminal"
	while [[ -z "$term" ]]; do
		parent="$(get_ppid "$parent")"
		[[ -z "$parent" ]] && break
		name="$(get_process_name "$parent")"
		case ${name// } in
			"${SHELL/*\/}"|*"sh"|"screen"|"su"*) ;;
			"login"*|*"Login"*|"init"|"(init)")
				term="$(tty)"
			;;
			"ruby"|"1"|"tmux"*|"systemd"|"sshd"*|"python"*|"USER"*"PID"*|"kdeinit"*|"launchd"*)
				break
			;;
			"gnome-terminal-") term="gnome-terminal" ;;
			"urxvtd")		  term="urxvt" ;;
			*"nvim")		   term="Neovim Terminal" ;;
			*"NeoVimServer"*)  term="VimR Terminal" ;;
			*)
				[[ $os == Linux ]] && term=$(realpath "/proc/$parent/exe")
				term="${name##*/}"
				[[ $term == .*-wrapped ]] && {
				   term="${term#.}"
				   term="${term%-wrapped}"
				}
			;;
		esac
	done
	term_run=1
}
get_term_font() {
	((term_run != 1)) && get_term
	case $term in
		"st")
			term_font="$(ps -o command= -p "$parent" | grep -F -- "-f")"
			if [[ "$term_font" ]]; then
				term_font="${term_font/*-f/}"
				term_font="${term_font/ -*/}"
			else
				[[ -L "/proc/$parent/exe" ]] && binary="/proc/$parent/exe" || binary="$(type -p st)"
				[[ -n "$binary" ]] && \
					term_font="$(strings "$binary" | grep -F -m 1 \
														  -e "pixelsize=" \
														  -e "size=" \
														  -e "antialias=" \
														  -e "autohint=")"
			fi
			term_font="${term_font/xft:}"
			term_font="${term_font/:*}"
		;;
	esac
}
get_disk() {
	df_flags=(-P -h)
	IFS=$'\n' read -d "" -ra disks <<< "$(df "${df_flags[@]}" "${disk_show[@]:-/}")"
	unset "disks[0]"
	[[ ${disks[*]} ]] || {
		err "Disk: df failed to print the disks, make sure the disk_show array is set properly."
		return
	}
	for disk in "${disks[@]}"; do
		IFS=" " read -ra disk_info <<< "$disk"
		disk_perc=${disk_info[-2]/\%}
		case $disk_percent in
			off) disk_perc=
		esac
		case $df_version in
			*befhikm*)
				disk="$((disk_info[-4]/1024/1024))G / $((disk_info[-5]/1024/1024))G"
				disk+="${disk_perc:+ ($disk_perc%)}"
			;;
			*)
				disk="${disk_info[-4]/i} / ${disk_info[-5]/i}${disk_perc:+ ($disk_perc%)}"
			;;
		esac
		case $disk_subtitle in
			name)
				disk_sub=${disk_info[*]::${#disk_info[@]}-5}
			;;
			dir)
				disk_sub=${disk_info[-1]/*\/}
				disk_sub=${disk_sub:-${disk_info[-1]}}
			;;
			none) ;;
			*)
				disk_sub=${disk_info[-1]}
			;;
		esac
		case $disk_display in
			bar)	 disk="$(bar "$disk_perc" "100")" ;;
			infobar) disk+=" $(bar "$disk_perc" "100")" ;;
			barinfo) disk="$(bar "$disk_perc" "100")${info_color} $disk" ;;
			perc)	disk="${disk_perc}% $(bar "$disk_perc" "100")" ;;
		esac
		if [[ "$subtitle" ]]; then
			prin "$subtitle${disk_sub:+ ($disk_sub)}" "$disk"
		else
			prin "$disk_sub" "$disk"
		fi
	done
}
get_local_ip() {
	local_ip="$(ip route get 1 | awk -F'src' '{print $2; exit}')"
	local_ip="${local_ip/uid*}"
	[[ -z "$local_ip" ]] && local_ip="$(ifconfig -a | awk '/broadcast/ {print $2; exit}')"
}
get_public_ip() {
	if type -p dig >/dev/null; then
		public_ip="$(dig +time=1 +tries=1 +short myip.opendns.com @resolver1.opendns.com)"
	   [[ "$public_ip" =~ ^\; ]] && unset public_ip
	fi
	if [[ -z "$public_ip" ]] && type -p drill >/dev/null; then
		public_ip="$(drill myip.opendns.com @resolver1.opendns.com | \
					 awk '/^myip\./ && $3 == "IN" {print $5}')"
	fi
	if [[ -z "$public_ip" ]] && type -p curl >/dev/null; then
		public_ip="$(curl --max-time "$public_ip_timeout" -w '\n' "$public_ip_host")"
	fi
	if [[ -z "$public_ip" ]] && type -p wget >/dev/null; then
		public_ip="$(wget -T "$public_ip_timeout" -qO- "$public_ip_host")"
	fi
}
get_users() {
	users="$(who | awk '!seen[$1]++ {printf $1 ", "}')"
	users="${users%\,*}"
}
get_locale() {
	locale="$sys_locale"
}
get_gpu_driver() {
	gpu_driver="$(lspci -nnk | awk -F ': ' \
				  '/Display|3D|VGA/{nr[NR+2]}; NR in nr {printf $2 ", "; exit}')"
	gpu_driver="${gpu_driver%, }"
	if [[ "$gpu_driver" == *"nvidia"* ]]; then
		gpu_driver="$(< /proc/driver/nvidia/version)"
		gpu_driver="${gpu_driver/*Module  }"
		gpu_driver="NVIDIA ${gpu_driver/  *}"
	fi
}
get_cols() {
	local blocks blocks2 cols
	if [[ "$color_blocks" == "on" ]]; then
		printf -v block_width "%${block_width}s"
		for ((block_range[0]; block_range[0]<=block_range[1]; block_range[0]++)); do
			case ${block_range[0]} in
				[0-7])
					printf -v blocks  '%b\e[3%bm\e[4%bm%b' \
						"$blocks" "${block_range[0]}" "${block_range[0]}" "$block_width"
				;;
				*)
					printf -v blocks2 '%b\e[38;5;%bm\e[48;5;%bm%b' \
						"$blocks2" "${block_range[0]}" "${block_range[0]}" "$block_width"
				;;
			esac
		done
		printf -v block_spaces "%${block_height}s"
		[[ "$blocks"  ]] && cols+="${block_spaces// /${blocks}[mnl}"
		[[ "$blocks2" ]] && cols+="${block_spaces// /${blocks2}[mnl}"
		cols=${cols%%nl}
		cols=${cols//nl/
[${text_padding}C${zws}}
		((info_height+=block_range[1]>7?block_height+3:block_height+2))
		case $col_offset in
			"auto") printf '\n\e[%bC%b\n\n' "$text_padding" "${zws}${cols}" ;;
			*) printf '\n\e[%bC%b\n\n' "$col_offset" "${zws}${cols}" ;;
		esac
	fi
	unset -v blocks blocks2 cols
	prin=1
}
image_backend() {
	[[ "$image_backend" != "off" ]] && ! type -p convert &>/dev/null && \
		{ image_backend="ascii"; err "Image: Imagemagick not found, falling back to ascii mode."; }
	case ${image_backend:-off} in
		"ascii") print_ascii ;;
		"off") image_backend="off" ;;
		"caca" | "chafa" | "jp2a" | "iterm2" | "termpix" |\
		"tycat" | "w3m" | "sixel" | "pixterm" | "kitty" | "pot")
			get_image_source
			[[ ! -f "$image" ]] && {
				to_ascii "Image: '$image_source' doesn't exist, falling back to ascii mode."
				return
			}
			get_window_size
			((term_width < 1)) && {
				to_ascii "Image: Failed to find terminal window size."
				err "Image: Check the 'Images in the terminal' wiki page for more info,"
				return
			}
			printf '\e[2J\e[H'
			get_image_size
			make_thumbnail
			display_image || to_off "Image: $image_backend failed to display the image."
		;;
		*)
			err "Image: Unknown image backend specified '$image_backend'."
			err "Image: Valid backends are: 'ascii', 'caca', 'chafa', 'jp2a', 'iterm2', 'kitty',
											'off', 'sixel', 'pot', 'pixterm', 'termpix', 'tycat',
											'w3m')"
			err "Image: Falling back to ascii mode."
			print_ascii
		;;
	esac
	[[ "$image_backend" != "off" ]] && printf '\e[%sA\e[9999999D' "${lines:-0}"
}
print_ascii() {
	if [[ -f "$image_source" && ! "$image_source" =~ (png|jpg|jpeg|jpe|svg|gif) ]]; then
		ascii_data="$(< "$image_source")"
	elif [[ "$image_source" == "ascii" || $image_source == auto ]]; then
		:
	else
		ascii_data="$image_source"
	fi
	LC_ALL="$sys_locale"
	while IFS=$'\n' read -r line; do
		line=${line//\\\\/\\}
		line=${line//â/ }
		((++lines,${#line}>ascii_len)) && ascii_len="${#line}"
	done <<< "${ascii_data//\$\{??\}}"
	((lines==1)) && { lines=; ascii_len=; image_source=auto; get_distro_ascii; print_ascii; return; }
	ascii_data="${ascii_data//\$\{c1\}/$c1}"
	ascii_data="${ascii_data//\$\{c2\}/$c2}"
	ascii_data="${ascii_data//\$\{c3\}/$c3}"
	ascii_data="${ascii_data//\$\{c4\}/$c4}"
	ascii_data="${ascii_data//\$\{c5\}/$c5}"
	ascii_data="${ascii_data//\$\{c6\}/$c6}"
	((text_padding=ascii_len+gap))
	printf '%b\n' "$ascii_data${reset}"
	LC_ALL=C
}
get_image_source() {
	case $image_source in
		"auto" | "wall" | "wallpaper")
			get_wallpaper
		;;
		*)
			image_source="$(get_full_path "$image_source")"
			if [[ -d "$image_source" ]]; then
				shopt -s nullglob
				files=("${image_source%/}"/*.{png,jpg,jpeg,jpe,gif,svg})
				shopt -u nullglob
				image="${files[RANDOM % ${#files[@]}]}"
			else
				image="$image_source"
			fi
		;;
	esac
	err "Image: Using image '$image'"
}
get_wallpaper() {
	((de_run != 1)) && get_de
	type -p wal >/dev/null && [[ -f "${HOME}/.cache/wal/wal" ]] && \
		{ image="$(< "${HOME}/.cache/wal/wal")"; return; }
	case $de in
		"MATE"*)
			image="$(gsettings get org.mate.background picture-filename)"
		;;
		"Xfce"*)
			image="$(xfconf-query -c xfce4-desktop -p \
					 "/backdrop/screen0/monitor0/workspace0/last-image")"
		;;
		"Cinnamon"*)
			image="$(gsettings get org.cinnamon.desktop.background picture-uri)"
			image="$(decode_url "$image")"
		;;
		"GNOME"*)
			image="$(gsettings get org.gnome.desktop.background picture-uri)"
			image="$(decode_url "$image")"
		;;
		"Plasma"*)
			image=$XDG_CONFIG_HOME/plasma-org.kde.plasma.desktop-appletsrc
			image=$(awk -F '=' '$1 == "Image" { print $2 }' "$image")
		;;
		"LXQt"*)
			image="$XDG_CONFIG_HOME/pcmanfm-qt/lxqt/settings.conf"
			image="$(awk -F '=' '$1 == "Wallpaper" {print $2}' "$image")"
		;;
		*)
			if type -p feh >/dev/null && [[ -f "${HOME}/.fehbg" ]]; then
				image="$(awk -F\' '/feh/ {printf $(NF-1)}' "${HOME}/.fehbg")"
			elif type -p setroot >/dev/null && \
				 [[ -f "${XDG_CONFIG_HOME}/setroot/.setroot-restore" ]]; then
				image="$(awk -F\' '/setroot/ {printf $(NF-1)}' \
						 "${XDG_CONFIG_HOME}/setroot/.setroot-restore")"
			elif type -p nitrogen >/dev/null; then
				image="$(awk -F'=' '/file/ {printf $2;exit;}' \
						 "${XDG_CONFIG_HOME}/nitrogen/bg-saved.cfg")"
			else
				image="$(gsettings get org.gnome.desktop.background picture-uri)"
				image="$(decode_url "$image")"
			fi
		;;
	esac
	image="${image/file:\/\/}"
	image="$(trim_quotes "$image")"
	[[ "${image/*\./}" == "xml" ]] && image=""
}
get_w3m_img_path() {
	shopt -s nullglob
	w3m_paths=({/usr/{local/,},~/.nix-profile/}{lib,libexec,lib64,libexec64}/w3m/w3mi*)
	shopt -u nullglob
	[[ -x "${w3m_paths[0]}" ]] && \
		{ w3m_img_path="${w3m_paths[0]}"; return; }
	err "Image: w3m-img wasn't found on your system"
}
get_window_size() {
	if [[ "$image_backend" == "tycat" ]]; then
		printf '%b' '\e}qs\000'
	elif [[ -z $VTE_VERSION ]]; then
		case ${TMUX:-null} in
			"null") printf '%b' '\e[14t' ;;
			*)	  printf '%b' '\ePtmux;\e\e[14t\e\\ ' ;;
		esac
	fi
	case $bash_version in
		4|5) IFS=';t' read -d t -t 0.05 -sra term_size ;;
		*)   IFS=';t' read -d t -t 1 -sra term_size ;;
	esac
	unset IFS
	if [[ "$image_backend" == "tycat" ]]; then
		term_width="$((term_size[2] * term_size[0]))"
		term_height="$((term_size[3] * term_size[1]))"
	else
		term_height="${term_size[1]}"
		term_width="${term_size[2]}"
	fi
	if (( "${term_width:-0}" < 50 )) && [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
		if type -p xdotool &>/dev/null; then
			IFS=$'\n' read -d "" -ra win \
				<<< "$(xdotool getactivewindow getwindowgeometry --shell %1)"
			term_width="${win[3]/WIDTH=}"
			term_height="${win[4]/HEIGHT=}"
		elif type -p xwininfo &>/dev/null; then
			if type -p xdo &>/dev/null; then
				current_window="$(xdo id)"
			elif type -p xprop &>/dev/null; then
				current_window="$(xprop -root _NET_ACTIVE_WINDOW)"
				current_window="${current_window##* }"
			elif type -p xdpyinfo &>/dev/null; then
				current_window="$(xdpyinfo | grep -F "focus:")"
				current_window="${current_window/*window }"
				current_window="${current_window/,*}"
			fi
			if [[ "$current_window" ]]; then
				term_size=("$(xwininfo -id "$current_window")")
				term_width="${term_size[0]#*Width: }"
				term_width="${term_width/$'\n'*}"
				term_height="${term_size[0]/*Height: }"
				term_height="${term_height/$'\n'*}"
			fi
		fi
	fi
	term_width="${term_width:-0}"
}
get_term_size() {
	read -r lines columns <<< "$(stty size)"
	font_width="$((term_width / columns))"
	font_height="$((term_height / lines))"
}
get_image_size() {
	get_term_size
	case $image_size in
		"auto")
			image_size="$((columns * font_width / 2))"
			term_height="$((term_height - term_height / 4))"
			((term_height < image_size)) && \
				image_size="$term_height"
		;;
		*"%")
			percent="${image_size/\%}"
			image_size="$((percent * term_width / 100))"
			(((percent * term_height / 50) < image_size)) && \
				image_size="$((percent * term_height / 100))"
		;;
		"none")
			read -r width height <<< "$(identify -format "%w %h" "$image")"
			while ((width >= (term_width / 2) || height >= term_height)); do
				((width=width/2,height=height/2))
			done
			crop_mode="none"
		;;
		*)  image_size="${image_size/px}" ;;
	esac
	[[ "$image_backend" == "w3m" ]] && term_padding
	width="${width:-$image_size}"
	height="${height:-$image_size}"
	text_padding="$(((width + padding + xoffset) / font_width + gap))"
}
make_thumbnail() {
	image_name="${crop_mode}-${crop_offset}-${width}-${height}-${image//\/}"
	case ${image##*.} in
		"eps"|"pdf"|"svg"|"gif"|"png")
			image_name+=".png" ;;
		*)  image_name+=".jpg" ;;
	esac
	mkdir -p "${thumbnail_dir:=${XDG_CACHE_HOME:-${HOME}/.cache}/thumbnails/neofetch}"
	if [[ ! -f "${thumbnail_dir}/${image_name}" ]]; then
		[[ -z "$size" ]] && {
			read -r og_width og_height <<< "$(identify -format "%w %h" "$image")"
			((og_height > og_width)) && size="$og_width" || size="$og_height"
		}
		case $crop_mode in
			"fit")
				c="$(convert "$image" \
					-colorspace srgb \
					-format "%[pixel:p{0,0}]" info:)"
				convert \
					-background none \
					"$image" \
					-trim +repage \
					-gravity south \
					-background "$c" \
					-extent "${size}x${size}" \
					-scale "${width}x${height}" \
					"${thumbnail_dir}/${image_name}"
			;;
			"fill")
				convert \
					-background none \
					"$image" \
					-trim +repage \
					-scale "${width}x${height}^" \
					-extent "${width}x${height}" \
					"${thumbnail_dir}/${image_name}"
			;;
			"none")
				cp "$image" "${thumbnail_dir}/${image_name}"
			;;
			*)
				convert \
					-background none \
					"$image" \
					-strip \
					-gravity "$crop_offset" \
					-crop "${size}x${size}+0+0" \
					-scale "${width}x${height}" \
					"${thumbnail_dir}/${image_name}"
			;;
		esac
	fi
	image="${thumbnail_dir}/${image_name}"
}
display_image() {
	case $image_backend in
		"caca")
			img2txt \
				-W "$((width / font_width))" \
				-H "$((height / font_height))" \
				--gamma=0.6 \
			"$image"
		;;
		"chafa")
			chafa --stretch --size="$((width / font_width))x$((height / font_height))" "$image"
		;;
		"jp2a")
			jp2a \
				--colors \
				--width="$((width / font_width))" \
				--height="$((height / font_height))" \
			"$image"
		;;
		"kitty")
			kitty +kitten icat \
				--align left \
				--place "$((width/font_width))x$((height/font_height))@${xoffset}x${yoffset}" \
			"$image"
		;;
		"pot")
			pot \
				"$image" \
				--size="$((width / font_width))x$((height / font_height))"
		;;
		"pixterm")
			pixterm \
				-tc "$((width / font_width))" \
				-tr "$((height / font_height))" \
			"$image"
		;;
		"sixel")
			img2sixel \
				-w "$width" \
				-h "$height" \
			"$image"
		;;
		"termpix")
			termpix \
				--width "$((width / font_width))" \
				--height "$((height / font_height))" \
			"$image"
		;;
		"iterm2")
			printf -v iterm_cmd '\e]1337;File=width=%spx;height=%spx;inline=1:%s' \
				"$width" "$height" "$(base64 < "$image")"
			[[ -n "$TMUX" ]] && printf -v iterm_cmd '\ePtmux;\e%b\e'\\ "$iterm_cmd"
			printf '%b\a\n' "$iterm_cmd"
		;;
		"tycat")
			tycat \
				-g "${width}x${height}" \
			"$image"
		;;
		"w3m")
			get_w3m_img_path
			zws='\xE2\x80\x8B\x20'
			((bash_version>3)) && sleep 0.05
			printf '%b\n%s;\n%s\n' "0;1;$xoffset;$yoffset;$width;$height;;;;;$image" 3 4 |\
			"${w3m_img_path:-false}" -bg "$background_color" &>/dev/null
		;;
	esac
}
to_ascii() {
	err "$1"
	image_backend="ascii"
	print_ascii
	printf '\e[%sA\e[9999999D' "${lines:-0}"
}
to_off() {
	err "$1"
	image_backend="off"
	text_padding=
}
info() {
	[[ "$2" ]] && subtitle="$1"
	unset -v prin
	"get_${2:-$1}"
	[[ "$prin" ]] && return
	if [[ "$2" ]]; then
		output="$(trim "${!2}")"
	else
		output="$(trim "${!1}")"
	fi
	if [[ "$2" && "${output// }" ]]; then
		prin "$1" "$output"
	elif [[ "${output// }" ]]; then
		prin "$output"
	else
		err "Info: Couldn't detect ${1}."
	fi
	unset -v subtitle
}
prin() {
	if [[ "$(trim "$1")" && "$2" ]]; then
		[[ "$json" ]] && { printf '	%s\n' "\"${1}\": \"${2}\","; return; }
		string="${1}${2:+: $2}"
	else
		string="${2:-$1}"
		local subtitle_color="$info_color"
	fi
	string="$(trim "${string//$'\e[0m'}")"
	length="$(strip_sequences "$string")"
	length="${#length}"
	string="${string/:/${reset}${colon_color}${separator:=:}${info_color}}"
	string="${subtitle_color}${bold}${string}"
	printf '%b\n' "${text_padding:+\e[${text_padding}C}${zws}${string//\\n}${reset} "
	((++info_height))
	prin=1
}
get_underline() {
	[[ "$underline_enabled" == "on" ]] && {
		printf -v underline "%${length}s"
		printf '%b%b\n' "${text_padding:+\e[${text_padding}C}${zws}${underline_color}" \
						"${underline// /$underline_char}${reset} "
	}
	((++info_height))
	length=
	prin=1
}
get_bold() {
	case $ascii_bold in
		"on")  ascii_bold='\e[1m' ;;
		"off") ascii_bold="" ;;
	esac
	case $bold in
		"on")  bold='\e[1m' ;;
		"off") bold="" ;;
	esac
}
trim() {
	set -f
	set -- $*
	printf '%s\n' "${*//[[:space:]]/}"
	set +f
}
trim_quotes() {
	trim_output="${1//\'}"
	trim_output="${trim_output//\"}"
	printf "%s" "$trim_output"
}
strip_sequences() {
	strip="${1//$'\e['3[0-9]m}"
	strip="${strip//$'\e['[0-9]m}"
	strip="${strip//\\e\[[0-9]m}"
	strip="${strip//$'\e['38\;5\;[0-9]m}"
	strip="${strip//$'\e['38\;5\;[0-9][0-9]m}"
	strip="${strip//$'\e['38\;5\;[0-9][0-9][0-9]m}"
	printf '%s\n' "$strip"
}
set_colors() {
	c1="$(color "$1")${ascii_bold}"
	c2="$(color "$2")${ascii_bold}"
	c3="$(color "$3")${ascii_bold}"
	c4="$(color "$4")${ascii_bold}"
	c5="$(color "$5")${ascii_bold}"
	c6="$(color "$6")${ascii_bold}"
	[[ "$color_text" != "off" ]] && set_text_colors "$@"
}
set_text_colors() {
	if [[ "${colors[0]}" == "distro" ]]; then
		title_color="$(color "$1")"
		at_color="$reset"
		underline_color="$reset"
		subtitle_color="$(color "$2")"
		colon_color="$reset"
		info_color="$reset"
		((${1:-1} == 8)) && title_color="$reset"
		((${2:-7} == 8)) && subtitle_color="$reset"
		((${2:-7} == 7)) && subtitle_color="$(color "$1")"
		((${1:-1} == 7)) && title_color="$reset"
	else
		title_color="$(color "${colors[0]}")"
		at_color="$(color "${colors[1]}")"
		underline_color="$(color "${colors[2]}")"
		subtitle_color="$(color "${colors[3]}")"
		colon_color="$(color "${colors[4]}")"
		info_color="$(color "${colors[5]}")"
	fi
	if [[ "$bar_color_elapsed" == "distro" ]]; then
		bar_color_elapsed="$(color fg)"
	else
		bar_color_elapsed="$(color "$bar_color_elapsed")"
	fi
	case ${bar_color_total}${1} in
		distro[736]) bar_color_total=$(color "$1") ;;
		distro[0-9]) bar_color_total=$(color "$2") ;;
		*)		   bar_color_total=$(color "$bar_color_total") ;;
	esac
}
color() {
	case $1 in
		[0-6])	printf '%b\e[3%sm'   "$reset" "$1" ;;
		7 | "fg") printf '\e[37m%b'	"$reset" ;;
		*)		printf '\e[38;5;%bm' "$1" ;;
	esac
}
stdout() {
	image_backend="off"
	unset subtitle_color colon_color info_color underline_color bold title_color at_color \
		  text_padding zws reset color_blocks bar_color_elapsed bar_color_total \
		  c1 c2 c3 c4 c5 c6 c7 c8
}
err() {
	err+="$(color 1)[!]${reset} $1
"
}
get_full_path() {
	[[ -f "${PWD}/${1}" ]] && { printf '%s\n' "${PWD}/${1}"; return; }
	! cd "${1%/*}" && {
		err "Error: Directory '${1%/*}' doesn't exist or is inaccessible"
		err "	   Check that the directory exists or try another directory."
		exit 1
	}
	local full_dir="${1##*/}"
	while [[ -L "$full_dir" ]]; do
		full_dir="$(readlink "$full_dir")"
		cd "${full_dir%/*}" || exit
		full_dir="${full_dir##*/}"
	done
	full_dir="$(pwd -P)/${1/*\/}"
	[[ -e "$full_dir" ]] && printf '%s\n' "$full_dir"
}
get_user_config() {
	if [[ -f "$config_file" ]]; then
		source "$config_file"
		err "Config: Sourced user config. (${config_file})"
		return
	elif [[ -f "${XDG_CONFIG_HOME}/neofetch/config.conf" ]]; then
		source "${XDG_CONFIG_HOME}/neofetch/config.conf"
	fi
}
bar() {
	elapsed="$(($1 * bar_length / $2))"
	printf -v prog  "%${elapsed}s"
	printf -v total "%$((bar_length - elapsed))s"
	bar+="${bar_color_elapsed}${prog// /${bar_char_elapsed}}"
	bar+="${bar_color_total}${total// /${bar_char_total}}"
	[[ "$bar_border" == "on" ]] && \
		bar="$(color fg)[${bar}$(color fg)]"
	printf "%b" "${bar}${info_color}"
}
cache() {
	if [[ "$2" ]]; then
		mkdir -p "${cache_dir}/neofetch"
		printf "%s" "${1/*-}=\"$2\"" > "${cache_dir}/neofetch/${1/*-}"
	fi
}
get_cache_dir() {
	cache_dir="/tmp"
}
term_padding() {
	[[ -z "$term" ]] && get_term
	case $term in
		urxvt*|rxvt-unicode)
			[[ $xrdb ]] || xrdb=$(xrdb -query)
			[[ $xrdb != *internalBorder:* ]] &&
				return
			padding=${xrdb/*internalBorder:}
			padding=${padding/$'\n'*}
			[[ $padding =~ ^[0-9]+$ ]] ||
				padding=
		;;
	esac
}
dynamic_prompt() {
	[[ "$image_backend" == "off" ]]   && { printf '\n'; return; }
	[[ "$image_backend" != "ascii" ]] && ((lines=(height + yoffset) / font_height + 1))
	[[ "$image_backend" == "w3m" ]]   && ((lines=lines + padding / font_height + 1))
	((lines=lines>info_height?lines-info_height+1:1))
	printf -v nlines "%${lines}s"
	printf "%b" "${nlines// /\\n}"
}
cache_uname() {
	IFS=" " read -ra uname <<< "$(uname -srm)"
	kernel_name="${uname[0]}"
	kernel_version="${uname[1]}"
	kernel_machine="${uname[2]}"
	if [[ "$kernel_name" == "Darwin" ]]; then
		IFS=$'\n' read -d "" -ra sw_vers <<< "$(awk -F'<|>' '/key|string/ {print $3}' \
							"/System/Library/CoreServices/SystemVersion.plist")"
		for ((i=0;i<${#sw_vers[@]};i+=2)) {
			case ${sw_vers[i]} in
				ProductName)		  darwin_name=${sw_vers[i+1]} ;;
				ProductVersion)	   osx_version=${sw_vers[i+1]} ;;
				ProductBuildVersion)  osx_build=${sw_vers[i+1]}   ;;
			esac
		}
	fi
}
get_ppid() {
	case $os in
		"Windows")
			ppid="$(ps -p "${1:-$PPID}" | awk '{printf $2}')"
			ppid="${ppid/PPID}"
		;;
		"Linux")
			ppid="$(grep -i -F "PPid:" "/proc/${1:-$PPID}/status")"
			ppid="$(trim "${ppid/PPid:}")"
		;;
		*)
			ppid="$(ps -p "${1:-$PPID}" -o ppid=)"
		;;
	esac
	printf "%s" "$ppid"
}
get_process_name() {
	name="$(< "/proc/${1:-$PPID}/comm")"
	printf "%s" "$name"
}
decode_url() {
	decode="${1//+/ }"
	printf "%b" "${decode//%/\\x}"
}
usage() { printf "%s" "\
See neofetch - fastfetch is fast
"
exit 1
}
get_args() {
	[[ "$*" != *--config* && "$*" != *--no_config* ]] && get_user_config
	while [[ "$1" ]]; do
		case $1 in
			"--ascii" | "--caca" | "--chafa" | "--jp2a" | "--iterm2" | "--off" | "--pot" |\
			"--pixterm" | "--sixel" | "--termpix" | "--tycat" | "--w3m" | "--kitty")
				image_backend="${1/--}"
				case $2 in
					"-"* | "") ;;
					*) image_source="$2" ;;
				esac
			;;
			"--config")
				case $2 in
					"none" | "off" | "") ;;
					*)
						config_file="$(get_full_path "$2")"
						get_user_config
					;;
				esac
			;;
			"--no_config") no_config="on" ;;
			"--stdout") stdout="on" ;;
			"-v") verbose="on" ;;
			"-vv") set -x; verbose="on" ;;
			"--help") usage ;;
			"--version")
				printf '%s\n' "Neofetch $version"
				exit 1
			;;
		esac
		shift
	done
}
get_simple() {
	while [[ "$1" ]]; do
		[[ "$(type -t "get_$1")" == "function" ]] && {
			get_distro
			stdout
			simple=1
			info "$1" "$1"
		}
		shift
	done
	((simple)) && exit
}
get_distro_ascii() {
	set_colors 6 6 7 1
}
main() {
	cache_uname
	get_os
	eval "$config"
	get_args "$@"
	[[ $verbose != on ]] && exec 2>/dev/null
	get_simple "$@"
	get_distro
	get_bold
	get_distro_ascii
	[[ $stdout == on ]] && stdout
	[[ $TERM != minix && $stdout != on ]] && {
		trap 'printf "\e[?25h\e[?7h"' EXIT
		printf '\e[?25l\e[?7l'
	}
	image_backend
	get_cache_dir
	print_info
	dynamic_prompt
	[[ $image_backend == *w3m* ]] && display_image
	err "Neofetch command: $0 $*"
	err "Neofetch version: $version"
	[[ $verbose == on ]] && printf %b "$err" >&2
	while [[ $image_loop == on && $image_backend == w3m ]]; do
		display_image
		sleep 1
	done
	return 0
}
main "$@"
